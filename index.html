<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosmic Cupid: Gemini & Hand Gestures</title>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- MediaPipe Hands & Camera Utils -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #1a0b2e 0%, #000000 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
        }

        /* UI Overlay */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Let clicks pass through to canvas if needed */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        /* Top Controls */
        #controls {
            margin-top: 20px;
            pointer-events: auto;
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 30px;
            border: 1px solid rgba(255, 105, 180, 0.3);
            display: flex;
            gap: 10px;
            backdrop-filter: blur(5px);
        }

        input {
            background: transparent;
            border: none;
            border-bottom: 2px solid #ff69b4;
            color: #fff;
            font-size: 1.2rem;
            padding: 5px;
            text-align: center;
            outline: none;
            width: 200px;
        }

        button {
            background: linear-gradient(45deg, #ff69b4, #ff1493);
            border: none;
            padding: 8px 20px;
            color: white;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        button:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px #ff69b4;
        }

        /* Name Display under Heart */
        #heart-name {
            position: absolute;
            top: 60%; /* Approximate position under the 3D heart */
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            font-weight: bold;
            color: #fff;
            text-shadow: 0 0 10px #ff69b4, 0 0 20px #ff1493, 0 0 40px #ff1493;
            opacity: 0;
            transition: opacity 1s ease;
            pointer-events: none;
            text-align: center;
        }

        /* Bottom Action Area */
        #bottom-area {
            margin-bottom: 30px;
            text-align: center;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 80%;
            max-width: 600px;
        }

        #ai-response {
            font-style: italic;
            font-size: 1.1rem;
            color: #ffd1dc;
            text-shadow: 0 0 5px rgba(255, 105, 180, 0.5);
            min-height: 1.5em;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 10px;
            width: 100%;
            display: none; /* Hidden until generated */
        }

        #listen-btn {
            background: linear-gradient(45deg, #4b0082, #9400d3);
            font-size: 1.1rem;
            display: none; /* Hidden until name is set */
        }

        /* Webcam Preview (Small corner) */
        #webcam-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            opacity: 0.7;
            z-index: 5;
            pointer-events: none;
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Mirror effect */
        }

        /* Loading / Error Messages */
        #status-msg {
            color: #aaa;
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .loading {
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
    </style>
</head>
<body>

    <!-- WebGL Canvas -->
    <canvas id="bg-canvas"></canvas>

    <!-- Webcam Feed -->
    <div id="webcam-container">
        <video id="input_video"></video>
    </div>

    <!-- UI Overlay -->
    <div id="ui-layer">
        <div id="controls">
            <input type="text" id="beloved-name" placeholder="Name on your heart">
            <button onclick="setName()">Set Name</button>
        </div>

        <div id="heart-name"></div>

        <div id="bottom-area">
            <div id="ai-response"></div>
            <button id="listen-btn" onclick="generateAndSpeak()">✨ Listen to the Stars</button>
            <div id="status-msg">Allow camera access. Show <b>Open Hand</b> to disperse, <b>Fist</b> to gather love.</div>
        </div>
    </div>

    <script>
        // --- 1. CONFIG & STATE ---
        const apiKey = ""; // SYSTEM: Injected at runtime.
        let state = {
            mode: 'disperse', // 'disperse' or 'converge'
            name: '',
            isSpeaking: false,
            gestureConfidence: 0
        };
        const CONFIDENCE_THRESHOLD = 5; // Frames to hold gesture before switching
        let frameCounter = 0;
        let lastDetected = 'disperse';

        // --- 2. THREE.JS SETUP (Visuals) ---
        const canvas = document.getElementById('bg-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        // --- PARTICLE SYSTEM ---
        const PARTICLE_COUNT = 1500;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // Heart shape
        const randomPositions = new Float32Array(PARTICLE_COUNT * 3); // Starfield
        const colors = new Float32Array(PARTICLE_COUNT * 3);

        const color1 = new THREE.Color(0xff69b4); // Hot Pink
        const color2 = new THREE.Color(0xffffff); // White
        const color3 = new THREE.Color(0x9400d3); // Purple

        // Generate Particles
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // 1. Random Dispersed Positions
            const rX = (Math.random() - 0.5) * 80;
            const rY = (Math.random() - 0.5) * 50;
            const rZ = (Math.random() - 0.5) * 50;
            
            randomPositions[i * 3] = rX;
            randomPositions[i * 3 + 1] = rY;
            randomPositions[i * 3 + 2] = rZ;

            // Initialize current positions
            positions[i * 3] = rX;
            positions[i * 3 + 1] = rY;
            positions[i * 3 + 2] = rZ;

            // 2. Heart Target Positions
            // Parametric Heart: 
            // x = 16sin^3(t)
            // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
            // We extend this to 3D by adding random Z depth within the heart volume
            const t = Math.random() * Math.PI * 2;
            const scale = 0.5; // Scale down to fit camera
            
            // Add some randomness so they aren't just on the line
            const spread = 2; 

            let hx = 16 * Math.pow(Math.sin(t), 3);
            let hy = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            
            // Randomize slightly inside the volume
            hx *= scale;
            hy *= scale;
            const hz = (Math.random() - 0.5) * 5; 

            targetPositions[i * 3] = hx + (Math.random() - 0.5);
            targetPositions[i * 3 + 1] = hy + (Math.random() - 0.5);
            targetPositions[i * 3 + 2] = hz;

            // Colors
            const c = Math.random() > 0.5 ? (Math.random() > 0.5 ? color1 : color2) : color3;
            colors[i * 3] = c.r;
            colors[i * 3 + 1] = c.g;
            colors[i * 3 + 2] = c.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // Create a soft glow texture for particles
        const spriteCanvas = document.createElement('canvas');
        spriteCanvas.width = 32;
        spriteCanvas.height = 32;
        const ctx = spriteCanvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255,255,255,1)');
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 32, 32);
        const texture = new THREE.CanvasTexture(spriteCanvas);

        const material = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            map: texture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- ARROW ANIMATION SETUP ---
        // Simple cylinder for the shaft and cone for the tip
        const arrowGroup = new THREE.Group();
        const shaftGeo = new THREE.CylinderGeometry(0.1, 0.1, 8, 8);
        const tipGeo = new THREE.ConeGeometry(0.4, 1, 8);
        const arrowMat = new THREE.MeshBasicMaterial({ color: 0xffd700, transparent: true, opacity: 0 }); // Gold

        const shaft = new THREE.Mesh(shaftGeo, arrowMat);
        shaft.rotation.z = -Math.PI / 2;
        const tip = new THREE.Mesh(tipGeo, arrowMat);
        tip.rotation.z = -Math.PI / 2;
        tip.position.x = 4; // End of shaft

        arrowGroup.add(shaft);
        arrowGroup.add(tip);
        scene.add(arrowGroup);
        
        let arrowAnimating = false;
        let arrowProgress = 0;

        // --- 3. ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const positionsAttribute = geometry.attributes.position;
            const currentPositions = positionsAttribute.array;

            // Lerp factor determines speed of transition
            // If speaking, pulse the heart
            const pulse = state.isSpeaking ? 1 + Math.sin(Date.now() * 0.01) * 0.1 : 1;
            const lerpSpeed = 0.05;

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const ix = i * 3;
                const iy = i * 3 + 1;
                const iz = i * 3 + 2;

                let tx, ty, tz;

                if (state.mode === 'converge') {
                    // Go to Heart
                    tx = targetPositions[ix] * pulse;
                    ty = targetPositions[iy] * pulse;
                    tz = targetPositions[iz];
                } else {
                    // Go to Random + drift
                    tx = randomPositions[ix];
                    ty = randomPositions[iy];
                    tz = randomPositions[iz];
                    
                    // Add subtle drift in disperse mode
                    randomPositions[ix] += Math.sin(Date.now() * 0.001 + i) * 0.02;
                    randomPositions[iy] += Math.cos(Date.now() * 0.002 + i) * 0.02;
                }

                // Interpolate
                currentPositions[ix] += (tx - currentPositions[ix]) * lerpSpeed;
                currentPositions[iy] += (ty - currentPositions[iy]) * lerpSpeed;
                currentPositions[iz] += (tz - currentPositions[iz]) * lerpSpeed;
            }

            positionsAttribute.needsUpdate = true;
            particles.rotation.y += 0.002; // Slow rotation of entire system

            // Arrow Animation
            if (arrowAnimating) {
                arrowProgress += 0.02;
                // Move from left (-20) to right (20)
                arrowGroup.position.x = -30 + (arrowProgress * 60);
                
                // Opacity fade in/out
                let op = 1;
                if (arrowProgress < 0.2) op = arrowProgress * 5;
                if (arrowProgress > 0.8) op = (1 - arrowProgress) * 5;
                
                arrowMat.opacity = Math.max(0, Math.min(1, op));

                if (arrowProgress >= 1) {
                    arrowAnimating = false;
                    arrowMat.opacity = 0;
                }
            } else {
                arrowMat.opacity = 0;
            }

            renderer.render(scene, camera);
        }
        animate();

        // Handle Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // --- 4. GESTURE RECOGNITION (MediaPipe) ---
        const videoElement = document.getElementById('input_video');
        const nameDisplay = document.getElementById('heart-name');
        
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // Heuristic: Check distance between fingertips and wrist (landmark 0)
                // Tips: 8 (Index), 12 (Middle), 16 (Ring), 20 (Pinky)
                // Wrist: 0
                
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20];
                let avgDist = 0;

                tips.forEach(idx => {
                    const tip = landmarks[idx];
                    const dx = tip.x - wrist.x;
                    const dy = tip.y - wrist.y;
                    avgDist += Math.sqrt(dx*dx + dy*dy);
                });
                avgDist /= 4;

                // Threshold determined experimentally for normalized coordinates
                // < 0.15 usually means fist, > 0.25 usually means open
                let detected = avgDist < 0.2 ? 'converge' : 'disperse';

                // Simple debouncing
                if (detected === lastDetected) {
                    frameCounter++;
                } else {
                    frameCounter = 0;
                    lastDetected = detected;
                }

                if (frameCounter > CONFIDENCE_THRESHOLD) {
                    if (state.mode !== detected) {
                        setMode(detected);
                    }
                }
            }
        }

        function setMode(newMode) {
            state.mode = newMode;
            
            if (newMode === 'converge') {
                // Trigger effects
                document.getElementById('status-msg').innerText = "Heart formed! Love is gathering.";
                
                // Show name if set
                if (state.name) {
                    nameDisplay.style.opacity = 1;
                    nameDisplay.innerText = state.name;
                    nameDisplay.style.textShadow = "0 0 20px #ff1493, 0 0 40px #ff69b4";
                }

                // Trigger Arrow
                arrowProgress = 0;
                arrowAnimating = true;

            } else {
                document.getElementById('status-msg').innerText = "Show Fist to form Heart.";
                nameDisplay.style.opacity = 0;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        cameraFeed.start();


        // --- 5. UI LOGIC & GEMINI API ---

        function setName() {
            const input = document.getElementById('beloved-name');
            if (input.value.trim() !== "") {
                state.name = input.value.trim();
                document.getElementById('listen-btn').style.display = 'inline-block';
                input.style.borderColor = '#00ff00';
            } else {
                alert("Please enter a name first!");
            }
        }

        async function generateAndSpeak() {
            if (!state.name) {
                alert("Set a name first!");
                return;
            }

            const aiDiv = document.getElementById('ai-response');
            const statusMsg = document.getElementById('status-msg');
            const btn = document.getElementById('listen-btn');

            btn.disabled = true;
            btn.innerText = "Consulting the Stars...";
            aiDiv.style.display = 'block';
            aiDiv.innerHTML = "<span class='loading'>Listening to the cosmos...</span>";

            try {
                // 1. Text Generation
                const prompt = `Write one single-sentence romantic love line in English, referencing the cosmos, stars, or galaxies, that includes the name: ${state.name}. Keep it under 20 words. Poetic, magical, not cheesy.`;
                
                const textUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                
                const textResp = await fetch(textUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        contents: [{ parts: [{ text: prompt }] }]
                    })
                });

                if (!textResp.ok) throw new Error("Cosmic interference (Text API failed)");
                
                const textData = await textResp.json();
                const loveLine = textData.candidates[0].content.parts[0].text.trim();
                
                aiDiv.innerText = `"${loveLine}"`;

                // 2. TTS Generation
                btn.innerText = "Synthesizing Starlight...";
                
                const ttsUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
                
                const ttsPayload = {
                    contents: [{ parts: [{ text: loveLine }] }],
                    generationConfig: {
                        responseModalities: ["AUDIO"],
                        speechConfig: {
                            voiceConfig: {
                                prebuiltVoiceConfig: { voiceName: "Fenrir" } // Fenrir is usually deep/soft
                            }
                        }
                    }
                };

                const ttsResp = await fetch(ttsUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(ttsPayload)
                });

                if (!ttsResp.ok) throw new Error("Cosmic interference (Audio API failed)");
                
                const ttsData = await ttsResp.json();
                const audioContent = ttsData.candidates[0].content.parts[0].inlineData.data; // Base64 PCM

                // 3. Play Audio
                playPCM16(audioContent);
                state.isSpeaking = true;
                statusMsg.innerText = "The universe speaks...";

            } catch (err) {
                console.error(err);
                aiDiv.innerText = "The stars remain silent (Error: " + err.message + ")";
            } finally {
                btn.disabled = false;
                btn.innerText = "✨ Listen Again";
            }
        }

        // --- AUDIO UTILS (PCM -> WAV) ---
        function playPCM16(base64PCM) {
            const binaryString = atob(base64PCM);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }

            // Create WAV header
            const wavHeader = buildWavHeader(bytes.length, 24000, 1, 16); // Gemini TTS is usually 24kHz
            const wavBytes = new Uint8Array(wavHeader.length + bytes.length);
            wavBytes.set(wavHeader, 0);
            wavBytes.set(bytes, wavHeader.length);

            const blob = new Blob([wavBytes], { type: 'audio/wav' });
            const url = URL.createObjectURL(blob);
            const audio = new Audio(url);
            
            audio.onended = () => {
                state.isSpeaking = false;
                document.getElementById('status-msg').innerText = "Show Fist to form Heart.";
            };
            
            audio.play();
        }

        function buildWavHeader(dataLength, sampleRate, numChannels, bitsPerSample) {
            const buffer = new ArrayBuffer(44);
            const view = new DataView(buffer);

            // RIFF chunk descriptor
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + dataLength, true);
            writeString(view, 8, 'WAVE');

            // fmt sub-chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)
            view.setUint16(20, 1, true); // AudioFormat (1 for PCM)
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true); // ByteRate
            view.setUint16(32, numChannels * bitsPerSample / 8, true); // BlockAlign
            view.setUint16(34, bitsPerSample, true);

            // data sub-chunk
            writeString(view, 36, 'data');
            view.setUint32(40, dataLength, true);

            return new Uint8Array(buffer);
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

    </script>
</body>
</html>
