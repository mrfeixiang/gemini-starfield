<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’˜ Cupid's Starfield | AI äº¤äº’æ˜Ÿç©º</title>
    
    <!-- Three.js åŸºç¡€åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Three.js å­—ä½“åŠ è½½å™¨ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/geometries/TextGeometry.js"></script>

    <!-- MediaPipe Hands (æ‰‹åŠ¿è¯†åˆ«) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        /* ================== CSS æ ·å¼éƒ¨åˆ† ================== */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }
        
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€UIæ“ä½œ3D */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
            background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.6) 100%);
        }

        .header {
            color: rgba(255, 255, 255, 0.95);
            text-shadow: 0 0 15px rgba(255, 100, 150, 0.6);
            text-align: center;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        h1 {
            font-weight: 300;
            margin: 0;
            font-size: 2.2rem;
            letter-spacing: 4px;
        }

        .subtitle {
            font-size: 0.9rem;
            color: #ff99cc;
            margin-top: 0.5rem;
            letter-spacing: 1px;
            margin-bottom: 1.5rem;
        }

        /* è¾“å…¥åŒºåŸŸå®¹å™¨ */
        .controls-container {
            background: rgba(0, 0, 0, 0.4);
            padding: 15px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .input-row {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* è¾“å…¥æ¡†é€šç”¨æ ·å¼ */
        input[type="text"], input[type="password"] {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 8px 15px;
            border-radius: 20px;
            outline: none;
            font-family: inherit;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        input::placeholder { color: rgba(255,255,255,0.5); }

        input:focus {
            background: rgba(255, 255, 255, 0.2);
            border-color: #ff6699;
            box-shadow: 0 0 10px rgba(255, 100, 150, 0.3);
        }

        /* æŒ‰é’®æ ·å¼ */
        button {
            border: none;
            color: #fff;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        button#ai-generate {
            background: linear-gradient(135deg, #6e45e2 0%, #88d3ce 100%);
            box-shadow: 0 0 15px rgba(110, 69, 226, 0.4);
        }
        button#ai-generate:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(136, 211, 206, 0.6);
        }
        button#ai-generate:disabled {
            filter: grayscale(100%);
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        /* AI æ¶ˆæ¯æ¡† */
        #ai-message-box {
            margin-top: 15px;
            min-height: 24px;
            font-size: 1.1rem;
            color: #bde0fe;
            font-style: italic;
            text-shadow: 0 0 8px rgba(189, 224, 254, 0.8);
            opacity: 0;
            transition: opacity 0.5s ease;
            max-width: 600px;
            text-align: center;
        }

        /* åº•éƒ¨çŠ¶æ€ */
        .status-bar {
            text-align: right;
            color: rgba(255,255,255,0.6);
            font-size: 0.85rem;
        }
        #gesture-status {
            color: #ff6699;
            font-weight: bold;
            font-size: 1.1rem;
        }

        /* åŠ è½½é®ç½© */
        #loader {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease;
        }
        .loader-content { text-align: center; color: #ff6699; }
        .heart-icon { font-size: 4rem; animation: pulse 1.5s infinite; margin-bottom: 20px; }
        .loader-btn {
            margin-top: 20px;
            background: linear-gradient(135deg, #ff6699, #ff3366);
            padding: 10px 30px;
            pointer-events: auto;
            border: none; border-radius: 20px; color: white;
        }
        .loader-btn:disabled { background: #444; cursor: wait; }
        .skip-btn {
            margin-top: 15px; background: transparent; 
            text-decoration: underline; font-size: 0.8rem; opacity: 0.6;
            pointer-events: auto;
        }

        /* é¼ æ ‡æ¨¡å¼æ§åˆ¶ */
        .mouse-controls {
            position: fixed; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            display: flex; gap: 15px; z-index: 10;
            pointer-events: auto;
        }
        .mouse-btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
        }
        .mouse-btn.active {
            background: #ff6699; color: white; border: none;
        }

        .hidden { display: none !important; }
        .input_video { display: none; }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.1); opacity: 1; }
        }
    </style>
</head>
<body>

    <!-- 1. åŠ è½½é¡µ -->
    <div id="loader">
        <div class="loader-content">
            <div class="heart-icon">âœ¨</div>
            <div id="loading-status">æ­£åœ¨è¿æ¥æ˜Ÿé™…ç½‘ç»œ...</div>
            <button class="loader-btn" id="start-btn" disabled>èµ„æºåŠ è½½ä¸­...</button>
            <button class="skip-btn" id="mouse-mode-btn">è·³è¿‡æ‘„åƒå¤´ (ä½¿ç”¨é¼ æ ‡/è§¦æ§)</button>
        </div>
    </div>

    <video class="input_video"></video>

    <!-- 2. UI äº¤äº’å±‚ -->
    <div id="ui-layer">
        <div class="header">
            <h1>CUPID'S STARFIELD</h1>
            <div class="subtitle">AI å¤šæ¨¡æ€äº¤äº’å®éªŒ | By Prof. Fei Xiang</div>
            
            <div class="controls-container">
                <!-- ç¬¬ä¸€è¡Œï¼šAPI Key (å®‰å…¨èµ·è§ï¼Œç”±ç”¨æˆ·è¾“å…¥) -->
                <div class="input-row">
                    <input type="password" id="api-key-input" placeholder="åœ¨æ­¤ç²˜è´´ Gemini API Key" style="width: 200px;">
                </div>
                <!-- ç¬¬äºŒè¡Œï¼šåå­—è¾“å…¥ + ç”ŸæˆæŒ‰é’® -->
                <div class="input-row">
                    <input type="text" id="lover-name" placeholder="è¾“å…¥åå­— (å¦‚: Alice)..." maxlength="12" style="width: 150px;">
                    <button id="ai-generate">âœ¨ è†å¬æ˜Ÿè¯­</button>
                </div>
            </div>

            <div id="ai-message-box"></div>
        </div>

        <div class="status-bar">
            å½“å‰çŠ¶æ€: <span id="gesture-status">ç­‰å¾…æŒ‡ä»¤</span>
            <br>
            <span style="opacity: 0.7">Particles: <span id="particle-count">0</span></span>
        </div>
    </div>

    <!-- 3. é¼ æ ‡æ§åˆ¶ (å¤‡ç”¨) -->
    <div class="mouse-controls hidden" id="mouse-controls">
        <button class="mouse-btn active" id="btn-scatter">âœ‹ æ•£å¼€æ˜Ÿç©º</button>
        <button class="mouse-btn" id="btn-heart">ğŸ’˜ ä¸€ç®­ç©¿å¿ƒ</button>
    </div>

    <!-- 4. 3D ç”»å¸ƒ -->
    <div id="canvas-container"></div>

    <script>
        // ================== JavaScript é€»è¾‘éƒ¨åˆ† ==================

        // é…ç½®å‚æ•°
        const CONFIG = {
            particleCount: 12000,
            particleSize: 1.8,
            fieldRadius: 1000,
            baseSpeed: 0.001,
            lerpSpeed: 0.05,
            repelForce: 80,
            heartScale: 15,
            colors: [0xff6699, 0xff3366, 0xff99cc, 0xffffff],
            microSpeed: 0.005, // å¾®åŠ¨é€Ÿåº¦
            microRange: 15     // å¾®åŠ¨èŒƒå›´
        };

        // å…¨å±€å˜é‡
        let scene, camera, renderer, particles;
        let positionsInitial, positionsHeartArrow;
        let time = 0;
        let currentGesture = 'NONE'; // 'NONE', 'OPEN', 'FIST'
        let handPositionWorld = new THREE.Vector3(0, 0, 0);
        let handPositionNormalized = new THREE.Vector3(0, 0, 0);
        let belovedNameStr = "";
        let nameTextMesh, font, handIndicatorMesh;
        let isFontLoaded = false;
        let useMouseMode = false;
        let animationId; // ç”¨äºè¿½è¸ªåŠ¨ç”»å¾ªç¯

        // MediaPipe
        let hands, cameraMP;
        const videoElement = document.getElementsByClassName('input_video')[0];

        // åˆå§‹åŒ–
        init();

        function init() {
            initThreeJS();
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            document.getElementById('start-btn').addEventListener('click', startCamera);
            document.getElementById('mouse-mode-btn').addEventListener('click', startMouseMode);
            document.getElementById('ai-generate').addEventListener('click', handleAIGeneration);
            
            // é¼ æ ‡æ¨¡å¼äº‹ä»¶
            document.getElementById('btn-scatter').addEventListener('click', () => setMouseGesture('OPEN'));
            document.getElementById('btn-heart').addEventListener('click', () => setMouseGesture('FIST'));

            window.addEventListener('resize', onWindowResize, false);

            // é¢„åŠ è½½èµ„æº (å¸¦å®¹é”™å¤„ç†)
            preloadAssets().then(() => {
                // èµ„æºåŠ è½½æˆåŠŸ
                console.log("Assets loaded successfully");
                enableStart();
            }).catch((err) => {
                // èµ„æºåŠ è½½å¤±è´¥ (ä¾‹å¦‚å­—ä½“ç½‘ç»œé”™è¯¯)ï¼Œä»ç„¶å¼ºåˆ¶å¯åŠ¨
                console.warn("Asset loading warning:", err);
                console.log("Starting anyway...");
                enableStart();
            });
        }
        
        function enableStart() {
            const startBtn = document.getElementById('start-btn');
            startBtn.disabled = false;
            startBtn.innerText = "å¼€å¯æ‘„åƒå¤´ (æ‰‹åŠ¿äº¤äº’)";
            document.getElementById('loading-status').innerText = "èµ„æºå‡†å¤‡å°±ç»ª";
            
            // æ ¸å¿ƒä¿®å¤ï¼šç¡®ä¿åŠ¨ç”»å¾ªç¯å·²å¯åŠ¨
            if (!animationId) {
                animate();
            }
        }

        // ================== Three.js æ ¸å¿ƒ ==================
        function initThreeJS() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x1a0a12, 0.0008);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 5000);
            camera.position.z = 1200;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            // ç¡®ä¿èƒŒæ™¯é€æ˜ï¼Œä»¥ä¾¿çœ‹åˆ° CSS èƒŒæ™¯
            renderer.setClearColor(0x000000, 0); 
            container.appendChild(renderer.domElement);

            createParticles();
            createHandIndicator();
            document.getElementById('particle-count').innerText = CONFIG.particleCount.toLocaleString();
        }

        async function preloadAssets() {
            // 1. è®¡ç®—ç›®æ ‡å½¢æ€
            positionsHeartArrow = calculateHeartArrowShape(CONFIG.particleCount, CONFIG.heartScale);
            
            // 2. åŠ è½½å­—ä½“ (å¢åŠ  Promise è¶…æ—¶å¤„ç†ï¼Œé˜²æ­¢æ— é™ç­‰å¾…)
            return new Promise((resolve, reject) => {
                const loader = new THREE.FontLoader();
                const timeout = setTimeout(() => {
                    // å¦‚æœ 3ç§’å†…è¿˜æ²¡åŠ è½½å®Œå­—ä½“ï¼Œå°±å…ˆ resolve ä¹Ÿå°±æ˜¯æ”¾å¼ƒå­—ä½“ç»§ç»­è¿è¡Œ
                    console.warn("Font loading timed out, skipping text features.");
                    resolve(); 
                }, 3000);

                loader.load(
                    'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/fonts/gentilis_bold.typeface.json', 
                    (loadedFont) => {
                        clearTimeout(timeout);
                        font = loadedFont;
                        isFontLoaded = true;
                        resolve();
                    },
                    undefined, // onProgress
                    (err) => {
                        clearTimeout(timeout);
                        console.warn("Font load error:", err);
                        // å³ä½¿å‡ºé”™ä¹Ÿ resolveï¼Œä¿è¯ç¨‹åºä¸å¡æ­»
                        resolve(); 
                    }
                );
            });
        }

        function createParticles() {
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(CONFIG.particleCount * 3);
            positionsInitial = new Float32Array(CONFIG.particleCount * 3);
            const colors = new Float32Array(CONFIG.particleCount * 3);
            const sizes = new Float32Array(CONFIG.particleCount);
            const colorObj = new THREE.Color();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // çƒä½“åˆ†å¸ƒ
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = Math.cbrt(Math.random()) * CONFIG.fieldRadius;

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                positionsInitial[i * 3] = x;
                positionsInitial[i * 3 + 1] = y;
                positionsInitial[i * 3 + 2] = z;

                const hex = CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
                colorObj.setHex(hex);
                colors[i * 3] = colorObj.r;
                colors[i * 3 + 1] = colorObj.g;
                colors[i * 3 + 2] = colorObj.b;

                sizes[i] = Math.random() * CONFIG.particleSize + 0.5;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: CONFIG.particleSize * 6,
                map: generateSprite(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        // è®¡ç®—ä¸€ç®­ç©¿å¿ƒå½¢æ€
        function calculateHeartArrowShape(count, scale) {
            const target = new Float32Array(count * 3);
            const heartCount = Math.floor(count * 0.8);
            const arrowCount = count - heartCount;

            // å¿ƒå½¢
            for (let i = 0; i < heartCount; i++) {
                let t = Math.random() * Math.PI * 2;
                let u = Math.random() * Math.PI;
                let x = 16 * Math.pow(Math.sin(t), 3);
                let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2*Math.cos(3*t) - Math.cos(4*t);
                let z = (Math.random() - 0.5) * 10 * Math.sin(u);
                
                target[i*3] = x * scale;
                target[i*3+1] = y * scale + 100; // å‘ä¸Šåç§»
                target[i*3+2] = z * scale;
            }

            // ç®­çŸ¢
            const start = new THREE.Vector3(-400, -100, 100);
            const end = new THREE.Vector3(400, 300, -100);
            const dir = new THREE.Vector3().subVectors(end, start);
            const len = dir.length();
            dir.normalize();

            for (let i = 0; i < arrowCount; i++) {
                let idx = heartCount + i;
                let t = i / arrowCount;
                let pos = new THREE.Vector3();

                if (t > 0.95) { // ç®­å¤´
                    let coneT = (t - 0.95) / 0.05;
                    pos.copy(start).addScaledVector(dir, len * (0.95 + coneT * 0.05));
                    let rad = (1 - coneT) * 30;
                    let angle = Math.random() * Math.PI * 2;
                    let perp1 = new THREE.Vector3(0,1,0).cross(dir).normalize();
                    let perp2 = dir.clone().cross(perp1).normalize();
                    pos.addScaledVector(perp1, Math.cos(angle)*rad).addScaledVector(perp2, Math.sin(angle)*rad);
                } else if (t < 0.1) { // ç®­ç¾½
                    pos.copy(start).addScaledVector(dir, len * t);
                    let dist = Math.random() * 40 * (1 - t/0.1);
                    pos.y += dist * (Math.random() > 0.5 ? 1 : -1);
                } else { // ç®­èº«
                    pos.copy(start).addScaledVector(dir, len * t);
                    pos.add(new THREE.Vector3((Math.random()-0.5)*10, (Math.random()-0.5)*10, (Math.random()-0.5)*10));
                }
                target[idx*3] = pos.x;
                target[idx*3+1] = pos.y;
                target[idx*3+2] = pos.z;
            }
            return target;
        }

        // ============ åŠ¨ç”»å¾ªç¯ ============
        function animate() {
            animationId = requestAnimationFrame(animate);
            time += 0.01;

            if (particles) {
                particles.rotation.y += CONFIG.baseSpeed;
                updateParticles();
            }
            
            if (nameTextMesh && nameTextMesh.visible) {
                nameTextMesh.position.y = -300 + Math.sin(time * 2) * 10;
            }
            renderer.render(scene, camera);
        }

        function updateParticles() {
            const positions = particles.geometry.attributes.position.array;
            const localHand = handPositionWorld.clone().applyMatrix4(particles.matrixWorld.invert());

            // æ§åˆ¶åå­—æ˜¾ç¤º
            if (nameTextMesh) {
                nameTextMesh.visible = (currentGesture === 'FIST' && belovedNameStr !== "");
            }

            for (let i = 0; i < CONFIG.particleCount; i++) {
                const px = positions[i*3];
                const py = positions[i*3+1];
                const pz = positions[i*3+2];
                const idx3 = i*3;
                let tx, ty, tz;

                if (currentGesture === 'FIST') {
                    // ç›®æ ‡ï¼šå¿ƒå½¢
                    tx = positionsHeartArrow[idx3];
                    ty = positionsHeartArrow[idx3+1];
                    tz = positionsHeartArrow[idx3+2];
                } else {
                    // ç›®æ ‡ï¼šçƒå½¢æ˜Ÿç©º
                    tx = positionsInitial[idx3];
                    ty = positionsInitial[idx3+1];
                    tz = positionsInitial[idx3+2];

                    // æ–¥åŠ›æ•ˆæœ (ä»…å¼ æ‰‹æ—¶)
                    if (currentGesture === 'OPEN') {
                        const dx = px - localHand.x;
                        const dy = py - localHand.y;
                        const dz = pz - localHand.z;
                        const distSq = dx*dx + dy*dy + dz*dz;
                        if (distSq < 300*300) {
                            const dist = Math.sqrt(distSq);
                            const force = (1 - dist/300) * CONFIG.repelForce;
                            tx += (dx/dist) * force * 10;
                            ty += (dy/dist) * force * 10;
                            tz += (dz/dist) * force * 10;
                        }
                    }
                }

                // æ·»åŠ å¾®åŠ¨æ•ˆæœ (è®©æ˜Ÿç©ºçœ‹èµ·æ¥æ˜¯æ´»çš„)
                tx += Math.sin(time * CONFIG.microSpeed * (i%7+1)) * CONFIG.microRange;
                ty += Math.cos(time * CONFIG.microSpeed * (i%5+1)) * CONFIG.microRange;
                tz += Math.sin(time * CONFIG.microSpeed * (i%9+1)) * CONFIG.microRange;

                // å¼¹æ€§ç§»åŠ¨æ’å€¼
                positions[idx3] += (tx - px) * CONFIG.lerpSpeed;
                positions[idx3+1] += (ty - py) * CONFIG.lerpSpeed;
                positions[idx3+2] += (tz - pz) * CONFIG.lerpSpeed;
            }
            particles.geometry.attributes.position.needsUpdate = true;
        }

        // ============ AI åŠŸèƒ½ (Gemini) ============
        async function handleAIGeneration() {
            const nameInput = document.getElementById('lover-name').value.trim();
            const apiKey = document.getElementById('api-key-input').value.trim();
            const btn = document.getElementById('ai-generate');
            const msgBox = document.getElementById('ai-message-box');

            if (!nameInput) { alert("è¯·è¾“å…¥åå­—..."); return; }
            if (!apiKey) { alert("è¯·å…ˆè¾“å…¥ Gemini API Key (ç½‘é¡µä¸ä¼šä¿å­˜ï¼Œä»…ä¾›å½“å‰ä¼šè¯ä½¿ç”¨)"); return; }

            // æ›´æ–°åå­— 3D æ˜¾ç¤º
            if (nameInput !== belovedNameStr) {
                belovedNameStr = nameInput;
                updateNameText();
            }

            btn.disabled = true;
            btn.innerHTML = "âœ¨ æ­£åœ¨æ€è€ƒ...";
            msgBox.style.opacity = 0;

            try {
                // 1. ç”Ÿæˆè¯—æ­Œ
                const poem = await generatePoem(apiKey, nameInput);
                msgBox.innerText = `"${poem}"`;
                msgBox.style.opacity = 1;

                // 2. è¯­éŸ³æœ—è¯»
                btn.innerHTML = "âœ¨ æ­£åœ¨åˆæˆè¯­éŸ³...";
                await playTTS(apiKey, poem);
                btn.innerHTML = "âœ¨ å†æ¬¡è†å¬";
            } catch (err) {
                console.error(err);
                msgBox.innerText = "è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥ API Key æ˜¯å¦æ­£ç¡®";
                msgBox.style.opacity = 1;
                btn.innerHTML = "é‡è¯•";
            } finally {
                btn.disabled = false;
            }
        }

        async function generatePoem(key, name) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${key}`;
            const prompt = `ä½ æ˜¯ä¸€ä¸ªæµªæ¼«çš„æ˜Ÿé™…è¯—äººã€‚è¯·ä¸ºåå­—æ˜¯'${name}'çš„äººå†™ä¸€å¥ç®€çŸ­çš„æƒ…è¯ã€‚ä¸»é¢˜è¦åŒ…å«å®‡å®™ã€æ˜Ÿè¾°æˆ–æ°¸æ’ã€‚20å­—ä»¥å†…ï¼Œä¸­æ–‡ã€‚ä¸è¦ä»»ä½•è§£é‡Šï¼Œåªè¿”å›å¥å­ã€‚`;
            
            const response = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });
            
            if (!response.ok) throw new Error("Poem API Failed");
            const data = await response.json();
            return data.candidates?.[0]?.content?.parts?.[0]?.text || "æ˜Ÿæ²³ä¸‡é¡·ï¼Œä½ æ˜¯å”¯ä¸€çš„å¼•åŠ›ã€‚";
        }

        async function playTTS(key, text) {
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${key}`;
            const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Kore" } } }
                },
                model: "gemini-2.5-flash-preview-tts"
            };

            const response = await fetch(url, {
                method: 'POST',
                headers: {'Content-Type': 'application/json'},
                body: JSON.stringify(payload)
            });

            if (!response.ok) throw new Error("TTS API Failed");
            const data = await response.json();
            const audioData = data.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
            
            if (audioData) {
                const audio = new Audio("data:audio/wav;base64," + audioData);
                await audio.play();
            }
        }

        // ============ è¾…åŠ©å‡½æ•° ============
        function updateNameText() {
            if (!isFontLoaded) return;
            if (nameTextMesh) {
                scene.remove(nameTextMesh);
                nameTextMesh.geometry.dispose();
                nameTextMesh.material.dispose();
            }

            const geo = new THREE.TextGeometry(belovedNameStr, {
                font: font, size: 60, height: 10,
                curveSegments: 12, bevelEnabled: true, bevelThickness: 2, bevelSize: 1, bevelSegments: 5
            });
            geo.computeBoundingBox();
            const offset = -0.5 * (geo.boundingBox.max.x - geo.boundingBox.min.x);
            
            const mat = new THREE.MeshPhongMaterial({ color: 0xff99cc, emissive: 0xdd4477, specular: 0xffffff, shininess: 30 });
            nameTextMesh = new THREE.Mesh(geo, mat);
            nameTextMesh.position.set(offset, -300, 50);
            nameTextMesh.visible = false;
            scene.add(nameTextMesh);

            if (!scene.getObjectByName("textLight")) {
                const light = new THREE.PointLight(0xffffff, 1, 2000);
                light.position.set(0, -200, 500);
                light.name = "textLight";
                scene.add(light);
            }
        }

        function createHandIndicator() {
            const geo = new THREE.RingGeometry(20, 25, 32);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ffff, side: THREE.DoubleSide, transparent: true, opacity: 0 });
            handIndicatorMesh = new THREE.Mesh(geo, mat);
            scene.add(handIndicatorMesh);
        }

        function generateSprite() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255,200,220,1)');
            grad.addColorStop(0.4, 'rgba(255,100,150,0.8)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            return new THREE.Texture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ============ äº¤äº’ä¸ MediaPipe ============
        function startMouseMode() {
            useMouseMode = true;
            hideLoader();
            document.getElementById('mouse-controls').classList.remove('hidden');
        }

        function setMouseGesture(g) {
            currentGesture = g;
            document.getElementById('gesture-status').innerText = g === 'FIST' ? "æ¡æ‹³ (èšæ‹¢)" : "å¼ æ‰‹ (æ•£å¼€)";
            document.getElementById('btn-scatter').classList.toggle('active', g === 'OPEN');
            document.getElementById('btn-heart').classList.toggle('active', g === 'FIST');
        }

        function startCamera() {
            if(useMouseMode) return;
            document.getElementById('start-btn').innerText = "å¯åŠ¨ä¸­...";
            
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
            hands.onResults(onHandResults);

            cameraMP = new Camera(videoElement, {
                onFrame: async () => { await hands.send({ image: videoElement }); },
                width: 640, height: 480
            });
            cameraMP.start().then(hideLoader).catch(err => {
                alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼Œåˆ‡æ¢åˆ°é¼ æ ‡æ¨¡å¼");
                startMouseMode();
            });
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const marks = results.multiHandLandmarks[0];
                updateHandPos(marks);
                
                // ç®€å•çš„æ¡æ‹³æ£€æµ‹
                const tips = [8, 12, 16, 20];
                let curled = 0;
                tips.forEach(idx => {
                    const tip = marks[idx];
                    const wrist = marks[0];
                    if ((tip.x-wrist.x)**2 + (tip.y-wrist.y)**2 < 0.035) curled++;
                });

                if (curled >= 3) {
                    currentGesture = 'FIST';
                    document.getElementById('gesture-status').innerText = "æ¡æ‹³ (èšæ‹¢)";
                } else {
                    currentGesture = 'OPEN';
                    document.getElementById('gesture-status').innerText = "å¼ æ‰‹ (æ•£å¼€)";
                }
            } else {
                currentGesture = 'NONE';
                document.getElementById('gesture-status').innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                handPositionNormalized.set(-1,-1,-1);
                if(handIndicatorMesh) handIndicatorMesh.material.opacity = 0;
            }
        }

        function updateHandPos(marks) {
            const wrist = marks[0];
            const mid = marks[9];
            handPositionNormalized.x = (wrist.x + mid.x) / 2;
            handPositionNormalized.y = (wrist.y + mid.y) / 2;
            const size = Math.sqrt((wrist.x-mid.x)**2 + (wrist.y-mid.y)**2);
            handPositionNormalized.z = (1 - size) * 2 - 1;

            const vec = new THREE.Vector3(
                (1 - handPositionNormalized.x) * 2 - 1,
                -(handPositionNormalized.y * 2 - 1),
                0.5
            ).unproject(camera);
            
            const dir = vec.sub(camera.position).normalize();
            const dist = -camera.position.z / dir.z;
            handPositionWorld.copy(camera.position).add(dir.multiplyScalar(dist));

            if (handIndicatorMesh) {
                handIndicatorMesh.position.copy(handPositionWorld);
                handIndicatorMesh.material.opacity = 0.5;
                handIndicatorMesh.material.color.setHex(currentGesture === 'FIST' ? 0xff3366 : 0x00ffff);
            }
        }

        function hideLoader() {
            const l = document.getElementById('loader');
            l.style.opacity = 0;
            setTimeout(() => l.classList.add('hidden'), 800);
        }
    </script>
</body>
</html>
